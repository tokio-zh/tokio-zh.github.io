(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{147:function(t,e,a){"use strict";a.r(e);var n=a(0),s=Object(n.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"content"},[t._m(0),t._v(" "),a("p",[t._v("周一快乐！")]),t._v(" "),t._m(1),t._v(" "),a("p",[t._v("我很高兴地宣布Tokio现在有实验性的异步/等待支持！ 让我们深入挖掘一下。")]),t._v(" "),t._m(2),t._v(" "),a("p",[t._v("首先，Tokio "),a("code",[t._v("async / await")]),t._v("支持由一个新的crate提供，创造性地命名为"),a("a",{attrs:{href:"https://crates.io/crates/tokio-async-await",target:"_blank",rel:"noopener noreferrer"}},[a("code",[t._v("tokio-async-await")]),a("OutboundLink")],1),t._v("。 这个板条箱是Tokio顶部的垫片。 它包含与tokio（作为重新导出）相同的所有类型和功能，以及与async / await一起使用的其他帮助程序。")]),t._v(" "),a("p",[t._v("要使用tokio-async-await，您需要从配置为使用Rust的2018版本的包中依赖它。 它也适用于最近的Rust夜间版本。")]),t._v(" "),a("p",[t._v("在您的应用程序的Cargo.toml中，添加以下内容：")]),t._v(" "),t._m(3),a("p",[t._v("然后，在您的应用程序中，执行以下操作：")]),t._v(" "),t._m(4),a("p",[t._v("并运行它 (with nightly):")]),t._v(" "),t._m(5),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),a("p",[t._v("现在，让我们构建一些简单的东西：一个echo服务器（yay）。")]),t._v(" "),t._m(9),t._m(10),t._v(" "),a("p",[t._v("一旦我们获得了流，它就会被传递给handle函数进行处理。 让我们看看它是如何实现的。")]),t._v(" "),t._m(11),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._v(" "),a("p",[t._v("这只是一个开始，请查看存储库中的"),a("a",{attrs:{href:"https://github.com/tokio-rs/tokio/blob/master/tokio-async-await/examples",target:"_blank",rel:"noopener noreferrer"}},[t._v("examples"),a("OutboundLink")],1),t._v("目录以获取更多信息。甚至还有一个使用"),a("a",{attrs:{href:"https://github.com/tokio-rs/tokio/blob/master/tokio-async-await/examples/hyper.rs",target:"_blank",rel:"noopener noreferrer"}},[t._v("hyper"),a("OutboundLink")],1),t._v("。")]),t._v(" "),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._v(" "),a("p",[t._v("有了这个，祝你有个美好的一周！")])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"tokio对async-await的实验性支持"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tokio对async-await的实验性支持","aria-hidden":"true"}},[this._v("#")]),this._v(" Tokio对"),e("code",[this._v("async/await")]),this._v("的实验性支持")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("如果你还没有听说过，"),e("code",[this._v("async / await")]),this._v("是一个Rust正在为之工作的新功能。 它的目的是使异步编程变得简单（好吧，至少比现在简单一点）。 这项工作已经进行了一段时间，今天已经可以在Rust夜间频道上使用了。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"入门"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#入门","aria-hidden":"true"}},[this._v("#")]),this._v(" 入门")])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"language-toml extra-class"},[a("pre",{pre:!0,attrs:{class:"language-toml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# At the very top of the file")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key property"}},[t._v("cargo-features")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"edition"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# In the `[packages]` section")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key property"}},[t._v("edition")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"2018"')]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# In the `[dependencies]` section")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token key property"}},[t._v("tokio-async-await")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"0.1.0"')]),t._v("\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-rust,ignore extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('// The nightly features that are commonly needed with async / await\n#![feature(await_macro, async_await, futures_api)]\n\n// This pulls in the `tokio-async-await` crate. While Rust 2018\n// doesn\'t require `extern crate`, we need to pull in the macros.\n#[macro_use]\nextern crate tokio;\n\nfn main() {\n    // And we are async...\n    tokio::run_async(async {\n        println!("Hello");\n    });\n}\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-txt extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("cargo +nightly run\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("你正在使用 Tokio + "),e("code",[this._v("async")]),this._v(" / "),e("code",[this._v("await")]),this._v("!")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("请注意，要生成异步块，应使用"),e("code",[this._v("tokio :: run_async")]),this._v("函数（而不是"),e("code",[this._v("tokio :: run")]),this._v("）。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"走得更远"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#走得更远","aria-hidden":"true"}},[this._v("#")]),this._v(" 走得更远")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-rust,ignore extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('// Somewhere towards the top\n\n#[macro_use]\nextern crate tokio;\n\nuse tokio::net::{TcpListener, TcpStream};\nuse tokio::prelude::*;\n\n// more to come...\n\n// The main function\nfn main() {\n  let addr: SocketAddr = "127.0.0.1:8080".parse().unwrap();\n  let listener = TcpListener::bind(&addr).unwrap();\n\n    tokio::run_async(async {\n        let mut incoming = listener.incoming();\n\n        while let Some(stream) = await!(incoming.next()) {\n            let stream = stream.unwrap();\n            handle(stream);\n        }\n    });\n}\n')])])])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("p",[t._v("在此示例中，"),a("code",[t._v("incoming")]),t._v("是接受的TcpStream值的流。 我们使用"),a("code",[t._v("async / await")]),t._v("来迭代流。 目前，只有等待单个值（future）的语法，因此我们使用"),a("code",[t._v("next")]),t._v("组合器来获取流中下一个值的"),a("code",[t._v("future")]),t._v("。 这允许我们使用while语法迭代流。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-rust,ignore extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("fn handle(mut stream: TcpStream) {\n    tokio::spawn_async(async move {\n        let mut buf = [0; 1024];\n\n        loop {\n            match await!(stream.read_async(&mut buf)).unwrap() {\n                0 => break, // Socket closed\n                n => {\n                    // Send the data back\n                    await!(stream.write_all_async(&buf[0..n])).unwrap();\n                }\n            }\n        }\n    });\n}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("就像"),e("code",[this._v("run_async")]),this._v("一样，有一个"),e("code",[this._v("spawn_async")]),this._v("函数可以将"),e("code",[this._v("async")]),this._v("块作为任务生成。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("然后，为了执行echo逻辑，我们从套接字读入缓冲区并将数据写回同一个套接字。因为我们正在使用"),e("code",[this._v("async / await")]),this._v("，所以我们可以使用一个看起来堆栈分配的数组（它实际上最终在堆中）。")])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("p",[t._v("请注意，TcpStream具有"),a("code",[t._v("read_async")]),t._v("和"),a("code",[t._v("write_all_async")]),t._v("函数。这些函数执行与std中Read和Write特性上存在的同步等价物相同的逻辑。差异是，他们返回可以"),a("code",[t._v("awaited")]),t._v("的"),a("code",[t._v("futures")]),t._v("。")])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("p",[a("code",[t._v("* _async")]),t._v("函数通过使用扩展"),a("code",[t._v("traits")]),t._v("在"),a("code",[t._v("tokio-async-await crate")]),t._v("中定义。这些"),a("code",[t._v("traits")]),t._v("使用"),a("code",[t._v("tokio :: prelude :: *;")]),t._v("导入。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"一些笔记"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一些笔记","aria-hidden":"true"}},[this._v("#")]),this._v(" 一些笔记")])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("p",[t._v("首先，"),a("code",[t._v("tokio-async-await crate")]),t._v("仅提供"),a("code",[t._v("async / await")]),t._v("语法的兼容性。它没有为"),a("code",[t._v("futures")]),t._v(" 0.3箱提供支持。预计用户将继续使用"),a("code",[t._v("futures")]),t._v(" 0.1以保持与Tokio兼容。")])},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("p",[t._v("为了使这工作，"),a("code",[t._v("tokio-async-await crate")]),t._v("定义了自己的"),a("code",[t._v("await!")]),t._v("宏。这个宏是由std提供的一个垫片，可以等待"),a("code",[t._v("futures")]),t._v(" 0.1的"),a("code",[t._v("futures")]),t._v("。这就是兼容层能够保持轻量级和样板免费的方式。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("这只是一个开始。随着时间的推移，"),e("code",[this._v("async / await")]),this._v("支持将继续发展和改进.")])}],!1,null,null,null);e.default=s.exports}}]);