(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{160:function(t,s,e){"use strict";e.r(s);var a=e(0),r=Object(a.a)({},function(){var t=this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"futures"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#futures","aria-hidden":"true"}},[t._v("#")]),t._v(" Futures")]),t._v(" "),e("p",[t._v("让我们仔细看看futures。Tokio构建在"),e("code",[t._v("futures")]),t._v("crate 之上并使用其运行时模型。这允许它也使用futures库与其他库互操作。")]),t._v(" "),e("p",[t._v("注意：此运行时模型与其他语言中的异步库非常不同。虽然在较高的层面上，API看起来很相似，但代码执行方式却有所不同。")]),t._v(" "),e("p",[t._v("我们将在下一节中仔细研究运行时，但是对运行时的基本了解是理解"),e("code",[t._v("Future")]),t._v("的必要条件。为了获得这种理解，我们首先看一下Rust默认使用的同步模型，看看它与Tokio的异步模型有何不同。")]),t._v(" "),e("h2",{attrs:{id:"同步模型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步模型","aria-hidden":"true"}},[t._v("#")]),t._v(" 同步模型")]),t._v(" "),e("p",[t._v("首先，让我们简要介绍一下Rust 标准库使用的同步（或阻塞）模型。")]),t._v(" "),e("div",{staticClass:"language-rust extra-class"},[e("pre",{pre:!0,attrs:{class:"language-rust"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// let socket = ...;")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mut")]),t._v(" buf "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" n "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" socket"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("read")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mut")]),t._v(" buf"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("unwrap")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Do something with &buf[..n];")]),t._v("\n")])])]),e("p",[t._v("调用"),e("code",[t._v("socket.read")]),t._v("时，根据"),e("code",[t._v("socket")]),t._v("在其接收缓冲区中是否具有等待处理的数据。 如果有待处理的数据，则read将立即返回，buf将填充该数据。 但是，如果没有未决数据，则read函数将阻止当前线程，直到收到数据。 一旦收到数据，buf将填充这个新接收的数据，并返回读取功能。")]),t._v(" "),e("p",[t._v("为了同时在许多不同的套接字上执行读取，每个套接字需要一个线程。 每个套接字使用一个线程不能很好地扩展到大量的套接字。 这被称为c10k问题。")]),t._v(" "),e("h2",{attrs:{id:"非阻塞套接字"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非阻塞套接字","aria-hidden":"true"}},[t._v("#")]),t._v(" 非阻塞套接字")]),t._v(" "),e("p",[t._v("在执行像"),e("code",[t._v("read")]),t._v("这样的操作时避免阻塞线程的方法是不阻塞线程！非阻塞套接字允许执行操作，如读取，而不会阻塞线程。当套接字在其接收缓冲区中没有待处理的数据时，read函数立即返回，表明套接字“未准备好”以执行读取操作。")]),t._v(" "),e("p",[t._v("使用"),e("code",[t._v("Tokio TcpStream")]),t._v("时，即使没有要读取的待处理数据，对"),e("code",[t._v("read")]),t._v("的调用也将立即返回一个值（ErrorKind :: WouldBlock）。如果没有待处理的数据，则调用者负责稍后再次调用"),e("code",[t._v("read")]),t._v("。诀窍是知道“晚些时候”的时间。")]),t._v(" "),e("p",[t._v("考虑非阻塞读取的另一种方法是“轮询”套接字以读取数据。")]),t._v(" "),e("p",[e("code",[t._v("Future")]),t._v("是围绕这种轮询模型的抽象。"),e("code",[t._v("Future")]),t._v("代表将在“未来某个时刻”提供的值。我们可以轮询"),e("code",[t._v("Future")]),t._v("并询问值是否准备就绪。我们来看看更多细节。")]),t._v(" "),e("h2",{attrs:{id:"仔细看看期货"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#仔细看看期货","aria-hidden":"true"}},[t._v("#")]),t._v(" 仔细看看期货")]),t._v(" "),e("p",[e("code",[t._v("future")]),t._v("是表示异步计算完成的值。通常，由于系统中其他位置发生的事件使"),e("code",[t._v("future")]),t._v("完成。虽然我们从基本"),e("code",[t._v("I/O")]),t._v("的角度看待事物，但您可以使用"),e("code",[t._v("future")]),t._v("来表示各种事件，例如：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("在线程池中执行的数据库查询。查询完成后，"),e("code",[t._v("future")]),t._v("完成，其值是查询的结果。")])]),t._v(" "),e("li",[e("p",[t._v("对服务器的RPC调用。当服务器回复时，"),e("code",[t._v("future")]),t._v("完成，其值是服务器的响应。")])]),t._v(" "),e("li",[e("p",[t._v("超时:当时间到了，"),e("code",[t._v("future")]),t._v("就完成了，它的值是（）。")])]),t._v(" "),e("li",[e("p",[t._v("在线程池上运行的长时间运行的CPU密集型任务。任务完成后，"),e("code",[t._v("future")]),t._v("完成，其值为任务的返回值。")])]),t._v(" "),e("li",[e("p",[t._v("从套接字读取字节。当字节准备就绪时，"),e("code",[t._v("future")]),t._v("就完成了 - 根据缓冲策略，字节可能直接返回，或作为副作用写入某个现有缓冲区。")])])]),t._v(" "),e("p",[e("code",[t._v("future")]),t._v("抽象的整个要点是允许异步函数，即不能立即返回值的函数，能够返回一些东西。")]),t._v(" "),e("p",[t._v("例如，异步HTTP客户端可以提供如下所示的get函数：")]),t._v(" "),e("div",{staticClass:"language-rust extra-class"},[e("pre",{pre:!0,attrs:{class:"language-rust"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pub")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" uri"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("str"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" ResponseFuture "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("...")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("然后，库的用户将使用该函数：")]),t._v(" "),e("div",{staticClass:"language-rust extra-class"},[e("pre",{pre:!0,attrs:{class:"language-rust"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" response_future "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" client"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("get")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"https://www.example.com"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[t._v("现在，"),e("code",[t._v("response_future")]),t._v("不是实际响应。 一旦收到回复，这将是一个"),e("code",[t._v("future")]),t._v("。 但是，由于调用者具有具体值（"),e("code",[t._v("future")]),t._v("），因此他们可以开始使用它。 例如，他们可以使用组合器链接计算，以便在收到响应后执行，或者可以将"),e("code",[t._v("future")]),t._v("传递给函数。")]),t._v(" "),e("div",{staticClass:"language-rust extra-class"},[e("pre",{pre:!0,attrs:{class:"language-rust"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" response_is_ok "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" response_future\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token closure-params"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v("response"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        response"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("status")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("is_ok")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("track_response_success")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("response_is_ok"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[t._v("所有与"),e("code",[t._v("future")]),t._v("一起采取的行动都不会立即执行任何工作。 他们不能，因为他们没有实际的HTTP响应。 相反，他们定义了响应"),e("code",[t._v("future")]),t._v("完成时要完成的工作。")]),t._v(" "),e("p",[e("code",[t._v("futures")]),t._v("箱和"),e("code",[t._v("Tokio")]),t._v("都有一系列组合功能，可以用来处理"),e("code",[t._v("future")]),t._v("。 到目前为止，我们已经看到"),e("code",[t._v("and_then")]),t._v("将两个"),e("code",[t._v("future")]),t._v("链接在一起，然后允许将"),e("code",[t._v("future")]),t._v("链接到前一个，即使前一个错误，映射只是将"),e("code",[t._v("future")]),t._v("的值从一种类型映射到另一种类型。")]),t._v(" "),e("p",[t._v("我们将在本指南后面探索更多的组合器。")]),t._v(" "),e("h2",{attrs:{id:"基于轮询模型的future"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基于轮询模型的future","aria-hidden":"true"}},[t._v("#")]),t._v(" 基于轮询模型的"),e("code",[t._v("Future")])]),t._v(" "),e("p",[t._v("如前所述，Rust"),e("code",[t._v("Future")]),t._v("基于轮询模型。 这意味着， Future一旦完成后，它不会负责将数据推送到某个地方，而是依赖于被询问它是否完成。")]),t._v(" "),e("p",[t._v("这是Rust"),e("code",[t._v("futures")]),t._v("库的一个独特方面。 其他编程语言的大多数"),e("code",[t._v("Future")]),t._v("库使用基于推送的模型，其中回调被提供给"),e("code",[t._v("Future")]),t._v("，并且计算立即使用计算结果调用回调。")]),t._v(" "),e("p",[t._v("使用基于轮询的模型提供了许多优点，包括作为零成本抽象，即与手动编写异步代码相比，使用Rust"),e("code",[t._v("Future")]),t._v("没有额外的开销。")]),t._v(" "),e("p",[t._v("我们将在下一节中仔细研究这种基于民意调查的模型。")]),t._v(" "),e("h2",{attrs:{id:"the-future-trait"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#the-future-trait","aria-hidden":"true"}},[t._v("#")]),t._v(" The Future trait")]),t._v(" "),e("p",[e("code",[t._v("Future")]),t._v("的特点如下：")]),t._v(" "),e("div",{staticClass:"language-rust extra-class"},[e("pre",{pre:!0,attrs:{class:"language-rust"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("trait")]),t._v(" Future "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/// The type of the value returned when the future completes.")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Item"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/// The type representing errors that occurred while processing the computation.")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" Error"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/// The function that will be repeatedly called to see if the future is")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/// has completed or not")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("poll")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("mut")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("self")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" Result"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Async"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Self")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),t._v("Item"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("Self")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),t._v("Error"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("现在，了解"),e("code",[t._v("Future")]),t._v("有两种相关类型非常重要： "),e("code",[t._v("Item")]),t._v("和"),e("code",[t._v("Error")]),t._v("。 "),e("code",[t._v("Item")]),t._v("是"),e("code",[t._v("Future")]),t._v("在完成时将产生的值的类型。 错误是如果在导致"),e("code",[t._v("Future")]),t._v("能够完成之前出现错误，"),e("code",[t._v("Future")]),t._v("可能会产生的错误类型。")]),t._v(" "),e("p",[t._v("最后，Futures有一种名为"),e("code",[t._v("poll")]),t._v("的方法。 我们不会在本节中详细介绍轮询模型，因为您不需要了解有关使用组合器的"),e("code",[t._v("Future")]),t._v("的轮询模型。 现在唯一需要注意的是，"),e("code",[t._v("poll")]),t._v("是在"),e("code",[t._v("tokio")]),t._v("运行时调用的，以便查看Future是否已完成。 如果你很好奇：Async是一个带有值的枚举，Ready(Item)或者NotReady告诉"),e("code",[t._v("tokio")]),t._v("运行时"),e("code",[t._v("Future")]),t._v("是否完成。")]),t._v(" "),e("p",[t._v("在以后的部分中，我们将从头开始实现"),e("code",[t._v("Future")]),t._v("，包括编写一个"),e("code",[t._v("poll")]),t._v("函数，该函数在"),e("code",[t._v("Future")]),t._v("完成时正确通知"),e("code",[t._v("tokio")]),t._v("运行时。")])])}],!1,null,null,null);s.default=r.exports}}]);