(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{145:function(t,e,r){"use strict";r.r(e);var i=r(0),n=Object(i.a)({},function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("div",{staticClass:"content"},[t._m(0),t._v(" "),r("p",[t._v("我很高兴宣布Tokio的新版本。 此版本包括第一个\nTokio Runtime的迭代。")]),t._v(" "),t._m(1),t._v(" "),r("p",[t._v("这就是现在编写基于多线程Tokio的服务器的方式：")]),t._v(" "),t._m(2),t._m(3),t._v(" "),r("p",[r("a",{attrs:{href:"https://tokio.rs/docs/getting-started/hello-world/",target:"_blank",rel:"noopener noreferrer"}},[t._v("guides"),r("OutboundLink")],1),t._v("和"),r("a",{attrs:{href:"https://github.com/tokio-rs/tokio/tree/master/examples",target:"_blank",rel:"noopener noreferrer"}},[t._v("examples"),r("OutboundLink")],1),t._v("已更新为使用运行时。")]),t._v(" "),t._m(4),t._v(" "),r("p",[t._v("Rust异步堆栈正在发展为一组松散耦合的组件。\n要运行基本的网络应用程序，您至少需要一个\n异步任务执行器和Tokio反应器的实例。因为\n一切都是分离的，这些各种各样有多种选择\n组件，但这为所有应用程序添加了一堆样板。")]),t._v(" "),r("p",[t._v("为了帮助缓解这个问题，Tokio现在提供了运行时的概念。这是一个\n预先配置的所有各种组件的包\n运行应用程序。")]),t._v(" "),r("p",[t._v("运行时的初始版本包括reactor和a\n基于"),r("a",{attrs:{href:"https://en.wikipedia.org/wiki/Work_stealing",target:"_blank",rel:"noopener noreferrer"}},[t._v("work-stealing"),r("OutboundLink")],1),t._v("的线程池，用于调度和执行应用程序\n码。这为应用程序提供了多线程默认值。")]),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),r("p",[t._v("如上例所示，使用Tokio运行时的最简单方法\n有两个功能：")]),t._v(" "),t._m(7),t._v(" "),r("p",[t._v("第一个函数需要一个未来种子应用程序并启动\n运行。粗略地说，它做了以下事情：")]),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),r("p",[t._v("这只是Tokio运行时的初始版本。即将发布的版本将\n包括对基于Tokio的应用程序有用的附加功能。一个\n博客文章即将推出更详细的路线图。")]),t._v(" "),r("p",[t._v("如前所述，目标是尽早和经常发布。提供新的\n使社区能够试验它们的功能。接下来的某个时候\n几个月，整个Tokio堆栈都会有一个突破性的释放，所以任何\n在此之前需要发现API中的更改。")]),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),r("p",[t._v("考虑到未来几个月预计会发生的流失量，\n我们希望能够帮助缓解各版本的过渡。")])])},[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"宣布tokio运行时"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#宣布tokio运行时","aria-hidden":"true"}},[this._v("#")]),this._v(" 宣布Tokio运行时")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"tl-dr"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tl-dr","aria-hidden":"true"}},[this._v("#")]),this._v(" tl;dr")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language-rust,ignore extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('extern crate tokio;\n\nuse tokio::net::TcpListener;\nuse tokio::prelude::*;\n\nfn process(s: TcpStream)\n  -> impl Future<Item = (), Error = ()> + Send\n{ ... }\n\nlet addr = "127.0.0.1:8080".parse().unwrap();\nlet listener = TcpListener::bind(&addr).unwrap();\n\nlet server = listener.incoming()\n    .map_err(|e| println!("error = {:?}", e))\n    .for_each(|socket| {\n        tokio::spawn(process(socket))\n    });\n\ntokio::run(server);\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("其中"),e("code",[this._v("process")]),this._v("表示一个用户定义的函数，它接受一个套接字和\n返回处理它的未来。 对于echo服务器，可能是\n从套接字读取所有数据并将其写回同一个套接字。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"什么是tokio-runtime"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是tokio-runtime","aria-hidden":"true"}},[this._v("#")]),this._v(" 什么是Tokio Runtime")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("工作窃取默认值适用于大多数应用程序。它使用了类似的\n策略如Go，Erlang，.NET，Java（ForkJoin池）等......\nTokio提供的实现是针对很多用例的\n"),e("strong",[this._v("不相关的")]),this._v("任务在单个线程池上复用。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"使用tokio-runtime"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用tokio-runtime","aria-hidden":"true"}},[this._v("#")]),this._v(" 使用Tokio Runtime")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("code",[this._v("tokio :: run")])]),this._v(" "),e("li",[e("code",[this._v("tokio :: spawn")]),this._v("。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("启动反应堆。")]),this._v(" "),e("li",[this._v("启动线程池。")]),this._v(" "),e("li",[this._v("将未来产生到线程池中。")]),this._v(" "),e("li",[this._v("阻塞线程，直到运行时空闲。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("运行时变为空闲"),e("strong",[this._v("所有")]),this._v("生成的期货已经完成并且"),e("strong",[this._v("全部")]),this._v("\n绑定到反应器的I / O资源被丢弃。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("从运行时的上下文中。该应用程序可能会产生额外的\n使用"),e("code",[this._v("tokio :: spawn")]),this._v("进入线程池的期货。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("或者，可以直接使用"),e("code",[this._v("Runtime")]),this._v("类型。这允许更多\n设置和使用运行时的灵活性。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"未来的改进"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#未来的改进","aria-hidden":"true"}},[this._v("#")]),this._v(" 未来的改进")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"tokio-core"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#tokio-core","aria-hidden":"true"}},[this._v("#")]),this._v(" Tokio-core")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("还有一个新的'tokio-core"),e("code",[this._v("版本。此版本更新")]),this._v("tokio-core"),e("code",[this._v("在引擎盖下使用")]),this._v("tokio"),e("code",[this._v("。这使所有现有的 目前依赖于")]),this._v("tokio-core`（如Hyper）的应用程序和库\n能够使用Tokio运行时带来的改进\n要求改变。")])}],!1,null,null,null);e.default=n.exports}}]);