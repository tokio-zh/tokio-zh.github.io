(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{179:function(t,n,s){"use strict";s.r(n);var a=s(0),e=Object(a.a)({},function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),s("p",[t._v("Rust标准库提供对网络和I/O的支持，例如TCP连接，UDP套接字，读取和写入文件等。但是，这些操作都是同步或"),s("em",[t._v("阻塞")]),t._v("的，这意味着当它们被调用时，当前线程可能会停止执行并进入睡眠状态，直到它被解除阻塞。例如，"),s("a",{attrs:{href:"https://doc.rust-lang.org/std/io/trait.Read.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("std::io::Read"),s("OutboundLink")],1),t._v("中的"),s("code",[t._v("read")]),t._v("方法会阻塞当前线程，直到能读取到数据。在使用Future的时候，这种行为会有问题，因为我们希望在等待I/O完成时继续执行我们可能拥有的其他Future。")]),t._v(" "),s("p",[t._v("为了实现这一点，Tokio提供了许多标准库I/O资源的非阻塞版本，例如"),s("a",{attrs:{href:"https://docs.rs/tokio/0.1/tokio/fs/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("文件操作"),s("OutboundLink")],1),t._v("和"),s("a",{attrs:{href:"https://docs.rs/tokio/0.1/tokio/net/tcp/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("TCP"),s("OutboundLink")],1),t._v("，"),s("a",{attrs:{href:"https://docs.rs/tokio/0.1/tokio/net/udp/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("UDP"),s("OutboundLink")],1),t._v("和 "),s("a",{attrs:{href:"https://docs.rs/tokio/0.1/tokio/net/unix/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Unix"),s("OutboundLink")],1),t._v("套接字。这些操作为长时间运行的操作（如接受新的TCP连接）返回Future，并实现无阻塞 "),s("code",[t._v("std::io::Read")]),t._v("和"),s("code",[t._v("std::io::Write")]),t._v("的async版本，名为"),s("code",[t._v("AsyncRead")]),t._v("和 "),s("code",[t._v("AsyncWrite")]),t._v("。")]),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),s("p",[t._v("在幕后，Tokio使用"),s("a",{attrs:{href:"https://docs.rs/mio/*/mio",target:"_blank",rel:"noopener noreferrer"}},[t._v("mio"),s("OutboundLink")],1),t._v("和"),s("a",{attrs:{href:"https://docs.rs/tokio/0.1/tokio/fs/index.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("tokio-fs"),s("OutboundLink")],1),t._v("跟踪不同futures等待的各种I/O资源的状态，只要其中任何一个的状态发生变化，操作系统就会通知它。")]),t._v(" "),t._m(3),t._v(" "),s("p",[t._v("要了解它如何工作，请考虑以下"),s("a",{attrs:{href:"https://tools.ietf.org/html/rfc862",target:"_blank",rel:"noopener noreferrer"}},[t._v("echo\n服务器"),s("OutboundLink")],1),t._v("的实现：")]),t._v(" "),t._m(4),s("p",[t._v("更多例子，请参考 "),s("a",{attrs:{href:"https://github.com/tokio-rs/tokio/tree/master/examples",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),s("OutboundLink")],1),t._v(".")])])},[function(){var t=this.$createElement,n=this._self._c||t;return n("h1",{attrs:{id:"i-o概叙"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#i-o概叙","aria-hidden":"true"}},[this._v("#")]),this._v(" I/O概叙")])},function(){var t=this.$createElement,n=this._self._c||t;return n("p",[this._v("例如，如果没有可用的数据，非阻塞读写不会阻塞当前线程。相反，它们会立即返回 "),n("code",[this._v("WouldBlock")]),this._v("错误，同时保证（"),n("code",[this._v("Future::poll")]),this._v("）已安排当前任务在以后可以取得进展时被唤醒，例如当网络数据包到达时。")])},function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("p",[t._v("通过使用非阻塞的Tokio I/O类型，如果一个执行I/O操作的Future不能立即执行，也不会阻止其他Future的执行，它只是返回 "),s("code",[t._v("NotReady")]),t._v("，并依赖于"),s("ruby",[t._v("任务通知"),s("rt",[t._v("task notification")])]),t._v("，使"),s("code",[t._v("poll")]),t._v("方法再次被调用，那时该I/O应该会成功且不会阻塞。")])},function(){var t=this.$createElement,n=this._self._c||t;return n("h2",{attrs:{id:"一个服务器例子"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一个服务器例子","aria-hidden":"true"}},[this._v("#")]),this._v(" 一个服务器例子")])},function(){var t=this,n=t.$createElement,s=t._self._c||n;return s("div",{staticClass:"language-rust extra-class"},[s("pre",{pre:!0,attrs:{class:"language-rust"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" tokio"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),t._v("prelude"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("use")]),t._v(" tokio"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),t._v("net"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),t._v("TcpListener"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Set up a listening socket, just like in std::net")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" addr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"127.0.0.1:12345"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("parse")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("unwrap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" listener "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" TcpListener"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("bind")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&")]),t._v("addr"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("expect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"unable to bind TCP listener"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Listen for incoming connections.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// This is similar to the iterator of incoming connections that")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// .incoming() from std::net::TcpListener, produces, except that")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// it is an asynchronous Stream of tokio::net::TcpStream instead")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// of an Iterator of std::net::TcpStream.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" incoming "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" listener"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("incoming")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Since this is a Stream, not an Iterator, we use the for_each")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// combinator to specify what should happen each time a new")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// connection becomes available.")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" server "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" incoming\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("map_err")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("e"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("eprintln!")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"accept failed = {:?}"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("for_each")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token closure-params"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v("socket"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Each time we get a connection, this closure gets called.")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// We want to construct a Future that will read all the bytes")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// from the socket, and write them back on that same socket.")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// If this were a TcpStream from the standard library, a read or")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// write here would block the current thread, and prevent new")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// connections from being accepted or handled. However, this")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// socket is a Tokio TcpStream, which implements non-blocking")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// I/O! So, if we read or write from this socket, and the")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// operation would block, the Future will just return NotReady")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// and then be polled again in the future.")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// While we *could* write our own Future combinator that does an")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// (async) read followed by an (async) write, we'll instead use")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// tokio::io::copy, which already implements that. We split the")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// TcpStream into a read "half" and a write "half", and use the')]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// copy combinator to produce a Future that asynchronously")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// copies all the data from the read half to the write half.")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("reader"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" writer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" socket"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("split")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" bytes_copied "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" tokio"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),t._v("io"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("copy")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("reader"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" writer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" handle_conn "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" bytes_copied"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token closure-params"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v("amt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println!")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"wrote {:?} bytes"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" amt"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("map_err")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token closure-params"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")]),t._v("err"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("|")])]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("eprintln!")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"I/O error {:?}"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" err"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// handle_conn here is still a Future, so it hasn't actually")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// done any work yet. We *could* return it here; then for_each")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// would wait for it to complete before it accepts the next")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// connection. However, we want to be able to handle multiple")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// connections in parallel, so we instead spawn the future and")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v('// return an "empty" future that immediately resolves so that')]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Tokio will _simultaneously_ accept new connections and")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// service this one.")]),t._v("\n        tokio"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("spawn")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("handle_conn"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// The `server` variable above is itself a Future, and hasn't actually")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// done any work yet to set up the server. We need to run it on a Tokio")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// runtime for the server to really get up and running:")]),t._v("\ntokio"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("run")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("server"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])])}],!1,null,null,null);n.default=e.exports}}]);