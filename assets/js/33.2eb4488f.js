(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{169:function(t,s,a){"use strict";a.r(s);var n=a(0),r=Object(n.a)({},function(){var t=this.$createElement;this._self._c;return this._m(0)},[function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"返回futures"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#返回futures","aria-hidden":"true"}},[t._v("#")]),t._v(" 返回Futures")]),t._v(" "),a("p",[t._v("在处理 "),a("code",[t._v("future")]),t._v("时，您可能需要做的第一件事就是返回 "),a("code",[t._v("future")]),t._v("。 然而，与迭代器一样，这样做可能有点棘手。 有几种选择，从大多数到最不符合人体工程学：")]),t._v(" "),a("ul",[a("li",[t._v("Trait objects")]),t._v(" "),a("li",[t._v("impl Trait")]),t._v(" "),a("li",[t._v("Named types")]),t._v(" "),a("li",[t._v("Custom types")])]),t._v(" "),a("h2",{attrs:{id:"trait-objects"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#trait-objects","aria-hidden":"true"}},[t._v("#")]),t._v(" Trait objects")]),t._v(" "),a("p",[t._v("首先，您始终可以选择返回一个Box "),a("code",[t._v("trait")]),t._v("对象：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" Box"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Future"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Item "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" u32"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Error "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" io"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),t._v("Error"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("这个策略的好处是它很容易写下来（只是一个Box）并且易于创建。 就 "),a("code",[t._v("future")]),t._v("的方法变化而言，这也是最灵活的，因为任何类型的 "),a("code",[t._v("future")]),t._v("都可以作为不透明的Box Future返回。")]),t._v(" "),a("p",[t._v("这种方法的缺点是，在构建 "),a("code",[t._v("future")]),t._v("时需要运行时分配，在使用该 "),a("code",[t._v("future")]),t._v("时需要动态分派。 Box需要在堆上分配，然后将 "),a("code",[t._v("future")]),t._v("放在里面。 请注意，尽管这是此处唯一的分配，否则在执行 "),a("code",[t._v("future")]),t._v("时不会进行任何分配。")]),t._v(" "),a("p",[t._v("通常可以通过仅在您想要返回的 "),a("code",[t._v("future")]),t._v("长链的末尾装箱来降低成本，这仅需要整个链的单一分配和动态调度。")]),t._v(" "),a("h2",{attrs:{id:"impl-trait"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#impl-trait","aria-hidden":"true"}},[t._v("#")]),t._v(" impl Trait")]),t._v(" "),a("p",[t._v("如果您使用的Rust版本大于1.26，那么您可以使用语言功能impl Trait。 此语言功能将允许，例如：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" add_10"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("F"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" F"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("impl")]),t._v(" Future"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Item "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i32"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" Error "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" F"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),t._v("Error"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" F"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Future"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Item "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i32"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("|")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("这里我们用指定的关联类型指示返回类型是“实现Future的东西”。 除此之外，我们通常会像往常一样使用 "),a("code",[t._v("future")]),t._v("的组合器。")]),t._v(" "),a("p",[t._v("这种方法的优点在于它是零开销，没有Box需要，它对于 "),a("code",[t._v("future")]),t._v("的实现是最大的灵活性，因为实际的返回类型是隐藏的，并且它符合人体工程学，因为它类似于上面的漂亮Box示例。")]),t._v(" "),a("p",[t._v("这种方法的缺点是只使用Box更灵活 - 如果你可能返回两种不同类型的Future，然后你仍然必须返回"),a("code",[t._v("Box <Future <Item = F :: Item，Error = F :: Error>")]),t._v("而不是"),a("code",[t._v("impl Future <Item = F :: Item，Error = F :: Error>")]),t._v("。 然而，好消息是这种情况很少见; 一般来说，它应该是一个向后兼容的扩展，用于将返回类型从"),a("code",[t._v("Box")]),t._v("更改为"),a("code",[t._v("impl Trait")]),t._v("。")]),t._v(" "),a("h2",{attrs:{id:"named-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#named-types","aria-hidden":"true"}},[t._v("#")]),t._v(" Named types")]),t._v(" "),a("p",[t._v("如果您不想返回Box并希望坚持使用旧版本的Rust，另一种选择是直接编写返回类型：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" add_10"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("F"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" F"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" Map"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("F"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i32"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" i32"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("where")]),t._v(" F"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Future"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("Item "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" i32"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("do_map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" i32"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" i32 "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    f"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("map")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("do_map"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("这里我们将返回类型命名为编译器看到的完全一样。 map函数返回Map结构，该结构在内部包含future和执行map的函数。")]),t._v(" "),a("p",[t._v("这种方法的优点是它没有以前Box的运行时开销，并且可以在1.26之前的Rust版本上运行。")]),t._v(" "),a("p",[t._v("然而，缺点是，通常很难命名这种类型。 有时类型可能会变得非常大或完全无法命名。 这里我们使用函数指针"),a("code",[t._v("（fn（i32） - > i32）")]),t._v("，但我们理想情况下使用闭包。 不幸的是，返回类型暂时无法命名闭包。 它还会导致非常详细的签名，并向客户泄露实施细节。")]),t._v(" "),a("h2",{attrs:{id:"custom-types"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#custom-types","aria-hidden":"true"}},[t._v("#")]),t._v(" Custom types")]),t._v(" "),a("p",[t._v("最后，您可以将具体的返回类型包装在一个新类型中，并为它实现 "),a("code",[t._v("future")]),t._v("。 例如：")]),t._v(" "),a("div",{staticClass:"language-rust extra-class"},[a("pre",{pre:!0,attrs:{class:"language-rust"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" MyFuture "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    inner"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" Sender"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("i32"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("fn")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("->")]),t._v(" MyFuture "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("tx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" rx"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" oneshot"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("channel")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n    MyFuture "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" inner"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" tx "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("impl")]),t._v(" Future "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" MyFuture "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("在这个例子中，我们返回一个自定义类型MyFuture，我们直接为它实现Future trait。 此实现利用了底层的"),a("code",[t._v("Oneshot <i32>")]),t._v("，但也可以在此处实现任何其他类型的协议。")]),t._v(" "),a("p",[t._v("这种方法的好处是它不需要Box分配，它仍然是最大的灵活性。 MyFuture的实现细节对外界是隐藏的，因此可以在不破坏其他情况的情况下进行更改。")]),t._v(" "),a("p",[t._v("然而，这种方法的缺点是，这是返回 "),a("code",[t._v("future")]),t._v("最不符合人体工程学的方法。")])])}],!1,null,null,null);s.default=r.exports}}]);